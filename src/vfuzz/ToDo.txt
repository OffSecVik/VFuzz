	NEXT STEPS
	
> implement stable output with some kind of terminal control or GUI - DONE

> test performance metrics with new output

> implement CPU and RAM metrics


	OTHER

> url variable in WebRequester.buildRequest(url, payload) method is unnecessary? - FIXED

> Recursion Thread handling - Thread Pool? Who gets how many thread? Max threads?

	TESTING
	
> test against robust site (htb labs)

> ensure proper error handling (most important)

> test to see how flags are read - are the quotes part of the processed values? (e.g. --user-agent "Mozilla" - will the program read "Mozilla" or Mozilla?)

	FEATURES

> have --exclude-length exclude ranges of lengths (e.g. 200-450)

> allow ranges in status codes

> fix request building (new) - DONE

> Metrics
-> give extra thread in thread orchestrator to metrics class DONE
-> validate that everything metrics related is off when not using --metrics flag DONE

> Retry Logic
	> --max-retry flag DONE
	> DynamicRateLimiter class, which controls a variable that adjusts the fuzzer's speed depending on the number of exceptions caught within a time window
		> --no-limit turns off the rate limiter

> Print Class for pretty output and progress bar

> rate limiting DONE
-> Dynamic Rate Limiting
-> pressing plus or minus during fuzzing to increase the rate, having a button to enable/disable rate limiting (this would be super sick)
-> max value for exponential backoff

> Flags:
	-w (Path to Wordlist) - DONE
	-u (URL) - DONE
	-e (Exclude Status Code) - TEST IT - WORKS
	-l (Exclude Length) - //TODO TEST IT
	-H (add Header) -> have to be able to add large number of headers! - //TODO TEST IT
	-d (send post data, automatically sets RequestMode to POST) (CONFLICT CHECK)
	-a --user-agent (User-Agent) (CONFLICT CHECK with --random-agent)
	--random-agent (set random user agent)
	-r (read request from file)
	---> allow specification of a custom marker
	
> VHOST mode DONE - also added SUBDOMAIN mode

> Strip "/" from url if present - DONE - also ensured a scheme is present

> Handle receiving IPs instead of FQDNs DONE

> Recursive Fuzzing DONE

> POST/PUT requests -- POST DONE, PUT later (does it even make sense to fuzz with PUT requests?)

> File Extension Fuzzing

> Fuzzing from a Text file web request like SQLmap, and placing a * inside the file where to fuzz

-> Use Java Profiler to index performance of my tool?


	IDEAS
	
> pass a config object to components that require it


	LOG
	
> added URLEncoding the payload in WebRequester
-> should be able to turn this off with a flag, or maybe in performance mode



IDEAS FOR RECURSION

-> Implement an iterator instead of queue.take() to preserve the queue.
the iterator would get a custom wait implementation, so that it doesn't choke in case the queue is empty. DONE
then modify the requestBuilder to build a request for each recursion target, it needs to take url as argument DONE
for this, we need to save the recursive targets in a data structure (ArrayList) -> We have this in Hit class DONE
now on a hit we need to call another thread that starts fuzzing the new target with a new queue
